program TrainDriver;

{ Declarations section }

const
  UART_1 = 1;
  UART_2 = 2;
  


var

  TrapFlagPin : sbit at LATA4_bit;

// EEPROM SPI PINS
  CS_Bank_0                         : sbit at LATB6_bit;
  CS_Bank_0_Direction               : sbit at TRISB6_bit;
  EE_PROM_Hold                      : sbit at LATB5_bit;
  EEPROM_Hold_Direction             : sbit at TRISB5_bit;

  // DCC SIGNAL PINS
  H_Bridge_A_Lo                     : sbit at LATA1_bit;
  H_Bridge_A_Hi                     : sbit at LATB0_bit;
  H_Bridge_B_Lo                     : sbit at LATB1_bit;
  H_Bridge_B_Hi                     : sbit at LATB4_bit;

  H_Bridge_A_Lo_Direction           : sbit at TRISA1_bit;
  H_Bridge_A_Hi_Direction           : sbit at TRISB0_bit;
  H_Bridge_B_Lo_Direction           : sbit at TRISB1_bit;
  H_Bridge_B_Hi_Direction           : sbit at TRISB4_bit;

  DCC_Programming_ACK_Pin           : sbit at RB2_bit;                          // Input so use the port and not the latch
  DCC_Programming_ACK_Direction     : sbit at TRISB2_bit;

  PreambleSyncPin                   : sbit at LATB15_bit;                       // DCC Bus Transmitter     // Debug to find the start of the Preamble
  PreambleSyncPinDirection          : sbit at TRISB15_bit;                      // DCC Bus Transmitter

  Ack_TimerEnabled_Bit              : sbit at TON_T5CON_bit;                    // DCC Service Mode 5ms ACK Timer

  Dcc_Timer_PR                      : Word at PR1;                              // DCC Interrupt Rollover

 // TrapFlagPin                       : sbit at LATB3_bit;                      // OVERLOADING THE NMRA DCC TRANSMITTER CURRENT SENSE

// End DCC Connection Pins

  ServiceModeEnabled: Boolean;
  OffEnabled: Boolean;

procedure OPStack_DCC_Timer(); iv IVT_ADDR_T1INTERRUPT; ics ICS_AUTO;
begin
  T1IF_bit := 0;                                                                // Clear the Flag

  if OffEnabled then
  begin
    H_Bridge_A_Hi := 0;
    H_Bridge_B_Lo := 0;
    H_Bridge_A_Lo := 0;
    H_Bridge_B_Hi := 0;
  end else
  if ServiceModeEnabled then
  begin
    if ServiceModeInfo.iStateMachine <> STATE_SERVICEMODE_IDLE then
    begin
      if Programming.TX_Flags.TRANSMITTING_FLAG_DCC_PIN_BIT = 1 then
      begin
        if H_Bridge_A_Lo = 0 then
        begin
          H_Bridge_A_Hi := 0;
          H_Bridge_B_Lo := 0;
          H_Bridge_A_Lo := 1;
          H_Bridge_B_Hi := 1;
        end
      end else
      begin
        H_Bridge_A_Lo := 0;
        H_Bridge_B_Hi := 0;
        H_Bridge_A_Hi := 1;
        H_Bridge_B_Lo := 1;
      end;
      NMRA_DCC_58us_TimeTick(@Programming);
      NMRA_DCC_TransmitterStateMachine(@Programming, True, False);   // < 5us
      
      ServiceMode_56us_TimeTick;
      ServiceMode_StateMachine(@Programming);
      
    end else
    begin
      H_Bridge_A_Hi := 0;
      H_Bridge_B_Lo := 0;
      H_Bridge_A_Lo := 0;
      H_Bridge_B_Hi := 0;
    end
  end else
  begin
     // Command Station is in Main Line Mode
    if Track.TX_Flags.TRANSMITTING_FLAG_DCC_PIN_BIT = 1 then
    begin
      if H_Bridge_A_Lo = 0 then
      begin
        H_Bridge_A_Hi := 0; 
        H_Bridge_B_Lo := 0; 
        H_Bridge_A_Lo := 1; 
        H_Bridge_B_Hi := 1;
      end
    end else
    begin
      H_Bridge_A_Lo := 0;
      H_Bridge_B_Hi := 0;
      H_Bridge_A_Hi := 1;
      H_Bridge_B_Lo := 1;
    end;

    // Now we can update the xxxx_DCC_PIN_BIT flags for the next 56us time slot
    NMRA_DCC_58us_TimeTick(@Track);                                                         // < 1us
    NMRA_DCC_TransmitterStateMachine(@Track, False, False);   // < 5us
    NMRA_DCC_LoadPacketIntoTransmitterStateMachine(@Track, PREAMBLE_BIT_COUNT_NORMAL);      // < 11us    Max
  end
end;

procedure OPStack_5ms_Timer(); iv IVT_ADDR_T5INTERRUPT; ics ICS_AUTO;
begin
  T5IF_bit := 0;

  ServiceMode_5ms_TimeTick;
end;

procedure OPStack_100ms_Timer(); iv IVT_ADDR_T2INTERRUPT; ics ICS_AUTO;
begin
  T2IF_bit := 0;
  
  ServiceMode_100ms_TimeTick
end;

const
  SMI_READBYTE  = 0;
  SMI_WRITEBYTE = 1;
  SMI_READBIT   = 2;
  SMI_WRITEBIT  = 3;

type
  TServiceModeMessage = record
    AddressLo: Word;                        // [IN] Address of the CV to access
    AddressHi: Word;                        // [IN] Address of the CV to access
    Instruction: Byte;                      // [IN] What to do with that CV,  SMI_xxxx constant
    DataByte: Byte;                         // [IN/OUT] If a byte read then this is the current value of the CV, 
                                            //          if a write then this is the byte to write to the CV
                                            //          if a bit operation the bit index [0..7] is passed in and the Bit value is passed back
  end;

var
  DccGridConnectString: PGridConnectString;
  i, DataIndex: Integer;
  N_Found: Boolean;
  DccPacket: TDCCPacket;
  HexStr: string[3];
  ValueStr: string[6];
  W: Byte;
  ServiceModeMessage: TServiceModeMessage;
begin

  TRISB11_bit := 0; // Output
  
  LATB11_bit := 0;
  
  H_Bridge_A_Lo_Direction          := 0;
  H_Bridge_A_Hi_Direction          := 0;
  H_Bridge_B_Lo_Direction          := 0;
  H_Bridge_B_Hi_Direction          := 0;
  
  ServiceModeEnabled := False;
  OffEnabled := False;

  NMRA_DCC_Initialize(1850);     // Clock ticks every 31.25ns * 1856 = 58us interrupts
  MCU_Setup_Initialize;
  ServiceMode_Initialize;
//  MCU_EnableSerialFlash;
  MCU_EnableUART;
  MCU_Enable100msTimer;
  MCU_EnableDCCTimer;
  MCU_Enable5msServiceModeTimer;
 // MCU_Enable10msTimer;
 // MCU_EnableADC;

  TRISA4_bit := 0; // Output

  UART1_Write_Text('Mustangpeak Command Station'+LF);
 // CheckForInitializedEEPROM(EEPROM_BANK_0, _25AA1024);

  while True do
  begin
  
    if ServiceMode_Running then
    begin
      if ServiceMode_ResultsReady then
      begin

        if ServiceMode_Ack_Found then
        begin
          UART1_Write_Text('Ack Found: CV'+LF);
          IntToStr(ServiceModeInfo.CV, ValueStr);
          UART1_Write_Text(ValueStr+LF);
          IntToStr(ServiceModeInfo.Value, ValueStr);
          UART1_Write_Text(ValueStr+LF);
        end else
        begin
          UART1_Write_Text('Ack not Found'+LF);
          IntToStr(ServiceModeInfo.CV, ValueStr);
          UART1_Write_Text(ValueStr+LF);
        end;
        ServiceMode_Quit
      end;
    end;
    
    if UART1_Data_Ready then
    begin
      if GridConnect_DecodeMachine(UART1_Read, DccGridConnectString) then
      begin
        if DccGridConnectString^[1] = 'R' then  // Are you a Raw DCC Packet?
        begin
          i := 0;
          DataIndex := 0;
          N_Found := False;
          while DccGridConnectString^[i] <> ';' do  // Spin until we find the end of the packet
          begin
            if not N_Found then                     // Spin until we find the N in the packet
            begin
              N_Found := (DccGridConnectString^[i] = 'N') or (DccGridConnectString^[i] = 'n');
              Inc(i);
            end else
            begin
              HexStr[0] := DccGridConnectString^[i];
              HexStr[1] := DccGridConnectString^[i+1];
              HexStr[2] := #0;     // VERY IMPORTANT UNLESS YOU SET A STRING TO HEXSTR OR THE NULL WON'T BE SET AND LENGTH() FAILS IN THE HEXTOBYTE!!!!
              W := HexToByte(HexStr);
              DccPacket.PacketBytes[DataIndex] := W;
              DataIndex := DataIndex + 1;
              i := i + 2;  // 2 char = byte
            end;
          end;
          DccPacket.Flags := DataIndex;      // Only the first 3 bits are the length, rest set to zero

      {
          UART1_Write_Text(':R00000000N');
          for i := 0 to DccPacket.Flags - 1 do
          begin
            ByteToHex(DccPacket.PacketBytes[i], HexStr);
            UART1_Write_Text(HexStr);
          end;
          UART1_Write_Text(';');
          UART1_Write_Text(LF);
                                   }
          NMRA_DCC_QueuePacket(@Track, @DccPacket, False);
        end else
        if DccGridConnectString^[1] = 'S' then  // Are you a Service Mode Packet?
        begin
          i := 0;
          DataIndex := 0;
          ServiceModeMessage.Instruction := 0;
          ServiceModeMessage.AddressLo := 0;
          ServiceModeMessage.AddressHi := 0;
          ServiceModeMessage.DataByte := 0;
          
          N_Found := False;
          while DccGridConnectString^[i] <> ';' do  // Spin until we find the end of the packet
          begin
            if not N_Found then                     // Spin until we find the N in the packet
            begin
              N_Found := (DccGridConnectString^[i] = 'N') or (DccGridConnectString^[i] = 'n');
              Inc(i);
            end else
            begin // Start picking up 2 character at a time to create a Byte in each position
              HexStr[0] := DccGridConnectString^[i];
              HexStr[1] := DccGridConnectString^[i+1];
              HexStr[2] := #0;     // VERY IMPORTANT UNLESS YOU SET A STRING TO HEXSTR OR THE NULL WON'T BE SET AND LENGTH() FAILS IN THE HEXTOBYTE!!!!
              W := HexToByte(HexStr);
              
              case DataIndex of
                0 : ServiceModeMessage.Instruction := W;
                1 : ServiceModeMessage.AddressHi := W;
                2 : ServiceModeMessage.AddressLo := W shl 8;
                3 : ServiceModeMessage.AddressLo := ServiceModeMessage.AddressLo or W;
                4 : ServiceModeMessage.DataByte := W;
              end;

              DataIndex := DataIndex + 1;
              i := i + 2;  // 2 char = byte
            end;
          end;
          
          ServiceMode_EngageServiceMode(@Programming, True, SERVICEMODE_READ, SERVICE_MODE_TYPE_DIRECT_BYTE, 8, 0, 0);
          
          UART1_Write_Text(LF); UART1_Write_Text(LF); UART1_Write_Text(LF);
          ByteToStr(ServiceModeMessage.Instruction, HexStr); UART1_Write_Text( HexStr);
          UART1_Write_Text(LF);

          ByteToStr(ServiceModeMessage.AddressHi, HexStr); UART1_Write_Text( HexStr);
          ByteToStr(Hi(ServiceModeMessage.AddressLo), HexStr); UART1_Write_Text( HexStr);
          ByteToStr(Lo(ServiceModeMessage.AddressLo), HexStr); UART1_Write_Text( HexStr);
          UART1_Write_Text(LF);

          ByteToStr(ServiceModeMessage.DataByte, HexStr); UART1_Write_Text( HexStr);
          UART1_Write_Text(LF); UART1_Write_Text(LF); UART1_Write_Text(LF);
        end;
      end;
    end;
  end;
end.